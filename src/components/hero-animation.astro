<div id="hero-animation" class="absolute inset-0 -z-10 overflow-hidden"></div>

<script>
    const container = document.getElementById("hero-animation");

    if (container) {
        const initThree = async () => {
            const THREE = await import("three");

            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            const camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000,
            );
            camera.position.z = 50;
            camera.position.y = 20;
            camera.position.x = 0;

            const renderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true,
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const rows = 100;
            const cols = 100;
            const particleCount = rows * cols;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const scales = new Float32Array(particleCount);

            const separation = 2;
            const offsetX = (cols * separation) / 2;
            const offsetZ = (rows * separation) / 2;

            for (let i = 0; i < particleCount; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);

                const x = col * separation - offsetX;
                const z = row * separation - offsetZ;
                const y = 0;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                scales[i] = 1;
            }

            geometry.setAttribute(
                "position",
                new THREE.BufferAttribute(positions, 3),
            );
            geometry.setAttribute(
                "scale",
                new THREE.BufferAttribute(scales, 1),
            );

            const canvas = document.createElement("canvas");
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext("2d");
            if (context) {
                context.beginPath();
                context.arc(16, 16, 16, 0, 2 * Math.PI);
                context.fillStyle = "#ffffff";
                context.fill();
            }
            const sprite = new THREE.CanvasTexture(canvas);

            const material = new THREE.PointsMaterial({
                color: 0xff4d00, 
                size: 0.8,
                sizeAttenuation: true,
                map: sprite,
                alphaTest: 0.5,
                transparent: true,
                opacity: 0.8,
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            let count = 0;
            let mouseX = 0;
            let mouseY = 0;
            const onDocumentMouseMove = (event: MouseEvent) => {
                mouseX = (event.clientX - window.innerWidth / 2) * 0.1;
                mouseY = (event.clientY - window.innerHeight / 2) * 0.1;
            };

            document.addEventListener("mousemove", onDocumentMouseMove);

            const onWindowResize = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };

            window.addEventListener("resize", onWindowResize);

            const animate = () => {
                requestAnimationFrame(animate);

                const positions = particles.geometry.attributes.position
                    .array as Float32Array;

                count += 0.01;

                for (let i = 0; i < particleCount; i++) {
                    const x = positions[i * 3];
                    const z = positions[i * 3 + 2];

                    const y = Math.sin(x * 0.02 + z * 0.02 + count) * 4;

                    const dist = Math.sqrt(
                        Math.pow(x - mouseX, 2) + Math.pow(z - mouseY * 2, 2),
                    );
                    const ripple =
                        Math.max(0, (100 - dist) / 10) * Math.sin(count * 2);

                    positions[i * 3 + 1] = y + ripple;
                }

                particles.geometry.attributes.position.needsUpdate = true;

                camera.position.x += (mouseX * 0.5 - camera.position.x) * 0.05;
                camera.position.y +=
                    (-mouseY * 0.5 + 30 - camera.position.y) * 0.05;
                camera.lookAt(scene.position);

                renderer.render(scene, camera);
            };

            animate();
        };

        if (window.requestIdleCallback) {
            window.requestIdleCallback(() => initThree());
        } else {
            setTimeout(initThree, 100);
        }
    }
</script>
