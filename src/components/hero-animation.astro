<div id="hero-animation" class="absolute inset-0 -z-10 overflow-hidden"></div>

<script>
    import * as THREE from "three";

    const container = document.getElementById("hero-animation");

    if (container) {
        // Scene setup
        const scene = new THREE.Scene();
        // Fog to blend particles into the background depth
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(
            75,
            container.clientWidth / container.clientHeight,
            0.1,
            1000,
        );
        camera.position.z = 50;
        camera.position.y = 20;
        camera.position.x = 0;

        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Particles - Grid System
        const rows = 100;
        const cols = 100;
        const particleCount = rows * cols;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);

        const separation = 2; // Distance between particles
        const offsetX = (cols * separation) / 2;
        const offsetZ = (rows * separation) / 2;

        for (let i = 0; i < particleCount; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);

            const x = col * separation - offsetX;
            const z = row * separation - offsetZ;
            const y = 0;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            scales[i] = 1;
        }

        geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(positions, 3),
        );
        geometry.setAttribute("scale", new THREE.BufferAttribute(scales, 1));

        // Create a circular texture for nicer particles
        const sprite = new THREE.TextureLoader().load(
            "https://threejs.org/examples/textures/sprites/disc.png",
        );

        const material = new THREE.PointsMaterial({
            color: 0xff4d00, // Vibrant Orange
            size: 0.8,
            sizeAttenuation: true,
            map: sprite,
            alphaTest: 0.5,
            transparent: true,
            opacity: 0.8,
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Animation variables
        let count = 0;
        let mouseX = 0;
        let mouseY = 0;

        // Mouse interaction
        const onDocumentMouseMove = (event: MouseEvent) => {
            mouseX = (event.clientX - window.innerWidth / 2) * 0.1;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.1;
        };

        document.addEventListener("mousemove", onDocumentMouseMove);

        // Resize handler
        const onWindowResize = () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        };

        window.addEventListener("resize", onWindowResize);

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position
                .array as Float32Array;

            count += 0.01;

            for (let i = 0; i < particleCount; i++) {
                const x = positions[i * 3];
                const z = positions[i * 3 + 2];

                const y = Math.sin(x * 0.02 + z * 0.02 + count) * 4;

                const dist = Math.sqrt(
                    Math.pow(x - mouseX, 2) + Math.pow(z - mouseY * 2, 2),
                );
                const ripple =
                    Math.max(0, (100 - dist) / 10) * Math.sin(count * 2);

                positions[i * 3 + 1] = y + ripple;
            }

            particles.geometry.attributes.position.needsUpdate = true;

            camera.position.x += (mouseX * 0.5 - camera.position.x) * 0.05;
            camera.position.y +=
                (-mouseY * 0.5 + 30 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        };

        animate();
    }
</script>
